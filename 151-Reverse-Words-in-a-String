INTUITION:

Thought about it like this: if i reverse the entire string, the words automatically come in reverse order, but each word itself is backwards.
For example:
"the sky is blue" → "eulb si yks eht"
So all i need to do next is reverse each word individually, and everything falls into place.

MY APPROACH:

1. I reversed the whole string first. Now the words are in the right order, just with their letters reversed.

2. Went through the string and reversed each word to fix the letters.

3. While doing this, skiped any extra spaces — kept only one space between words and remove leading/trailing spaces.

4. At the end, i got a clean string with all the words reversed and nicely formatted.

COMPLEXITY:

Time complexity:
o(N) , that too in the worst case (optimal iterative solution)

Space complexity:
o(1) ,space used to store the output string not countted becuase that's mandatory space which is not included in SC

CLEAN C++ CODE:

class Solution {
public:
    string a;

    string chk(string s, int start, int end) {
        if (start < 0) return a;

        while (start >= 0 && s[start] == ' ')
            start--;

        if (start < 0) return a;

        end = start;

        while (start >= 0 && s[start] != ' ')
            start--;

        a.append(s.substr(start + 1, end - start));
        a.push_back(' ');

        return chk(s, start - 1, start - 1);
    }

    string reverseWords(string s) {
        a.clear();
        int n = s.size();
        chk(s, n - 1, n - 1);

        if (!a.empty() && a.back() == ' ')
            a.pop_back();

        return a;
    }
};
